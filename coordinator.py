# HANDOVER-V2-CHECKPOINT :: DO NOT EDIT THIS FILE WITHOUT REVIEWING HANDOVER.md
"""Data update coordinator for the BluPow integration."""
import asyncio
import logging
from typing import Any, Dict
from datetime import timedelta
from concurrent.futures import ThreadPoolExecutor
import functools
import subprocess
import json

from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed
from homeassistant.components import bluetooth

from .blupow_client import BluPowClient
from .const import DOMAIN

_LOGGER = logging.getLogger(__name__)


class BluPowDataUpdateCoordinator(DataUpdateCoordinator[Dict[str, Any]]):
    """Class to manage fetching BluPow data from the device."""

    def __init__(self, hass: HomeAssistant, mac_address: str) -> None:
        """Initialize the data update coordinator."""
        self.mac_address = mac_address
        self.client = BluPowClient(mac_address)
        self.ble_device = bluetooth.async_ble_device_from_address(
            hass, mac_address.upper(), connectable=True
        ) if mac_address else None
        self._executor = ThreadPoolExecutor(max_workers=1, thread_name_prefix="BluPow-BT")

        super().__init__(
            hass,
            _LOGGER,
            name=DOMAIN,
            update_interval=timedelta(seconds=30),
            update_method=self._async_update_data,
        )
        _LOGGER.info("BluPow coordinator initialized for device: %s", mac_address)

    async def _async_update_data(self) -> Dict[str, Any]:
        """Update data via library using isolated execution."""
        _LOGGER.debug(f"Starting data update for {self.mac_address}")
        
        try:
            # Use subprocess to run connection in completely isolated environment
            _LOGGER.info("Running connection in isolated subprocess...")
            
            # Create a standalone script that mimics our successful manual tests
            script = f'''
import asyncio
import sys
sys.path.append("/config/custom_components")

async def get_data():
    from blupow.blupow_client import BluPowClient
    
    client = BluPowClient("{self.mac_address}")
    try:
        connected = await client.connect()
        if connected:
            data = await client.read_device_info()
            await client.disconnect()
            
            if data and len(data) > 0:
                # Convert to JSON-serializable format
                json_data = {{}}
                for k, v in data.items():
                    if v is not None:
                        json_data[k] = str(v) if not isinstance(v, (int, float, bool, str)) else v
                    else:
                        json_data[k] = None
                
                print("SUCCESS:" + str(json_data))
                return True
            else:
                print("ERROR:No data retrieved")
                return False
        else:
            print("ERROR:Connection failed")
            return False
    except Exception as e:
        print(f"ERROR:{{str(e)}}")
        return False

asyncio.run(get_data())
'''
            
            # Run the script in subprocess with timeout
            process = await asyncio.create_subprocess_exec(
                'python3', '-c', script,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=20.0)
                
                output = stdout.decode().strip()
                if output.startswith("SUCCESS:"):
                    # Parse the returned data
                    data_str = output[8:]  # Remove "SUCCESS:" prefix
                    data = eval(data_str)  # Safe since we control the format
                    
                    _LOGGER.info(f"âœ… SUBPROCESS SUCCESS: Retrieved {len(data)} fields")
                    
                    # Log key values to prove it's working
                    key_values = {k: v for k, v in data.items() 
                                if k in ['model', 'input_voltage', 'battery_voltage', 'temperature'] 
                                and v is not None}
                    _LOGGER.info(f"ðŸŽ¯ REAL DATA: {key_values}")
                    
                    # Ensure connection_status is set correctly
                    data['connection_status'] = 'connected'
                    
                    return data
                else:
                    error_msg = output if output.startswith("ERROR:") else "Unknown error"
                    _LOGGER.error(f"Subprocess failed: {error_msg}")
                    
                    if stderr:
                        _LOGGER.error(f"Subprocess stderr: {stderr.decode()}")
                    
                    return self.client.get_data()
                    
            except asyncio.TimeoutError:
                _LOGGER.error("Subprocess timed out after 20 seconds")
                process.kill()
                return self.client.get_data()
                
        except Exception as exc:
            _LOGGER.error(f"Error running subprocess: {exc}")
            return self.client.get_data()

    @property
    def device_info(self) -> Dict[str, Any]:
        """Return basic device information."""
        model = "Unknown"
        if self.data and self.data.get('model_number'):
            model = self.data.get('model_number')

        name = "BluPow Device"
        if self.ble_device and self.ble_device.name:
            name = self.ble_device.name

        return {
            "identifiers": {(DOMAIN, self.mac_address)},
            "name": name,
            "model": model,
            "manufacturer": "Renogy",
        }

    async def enable_test_mode(self) -> None:
        """Enable test mode with simulated data for debugging."""
        _LOGGER.info("Enabling test mode for BluPow coordinator")
        # Override get_data to return test data
        original_get_data = self.client.get_data
        self.client.get_data = self.client.get_test_data
        await self.async_refresh()

    async def async_shutdown(self):
        """Shutdown coordinator."""
        if hasattr(self, '_executor'):
            self._executor.shutdown(wait=True)
        if self.client and self.client.is_connected:
            await self.client.disconnect()

