# HANDOVER-V2-CHECKPOINT :: DO NOT EDIT THIS FILE WITHOUT REVIEWING HANDOVER.md
"""Data update coordinator for the BluPow integration."""
import logging
from typing import Any, Dict
from datetime import timedelta

from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator
from homeassistant.components import bluetooth

from .blupow_client import BluPowClient
from .const import DOMAIN

_LOGGER = logging.getLogger(__name__)


class BluPowDataUpdateCoordinator(DataUpdateCoordinator[Dict[str, Any]]):
    """Class to manage fetching BluPow data from the device."""

    def __init__(self, hass: HomeAssistant, client: BluPowClient, update_interval: int) -> None:
        """Initialize the data update coordinator."""
        self.client = client
        self.ble_device = bluetooth.async_ble_device_from_address(
            hass, client.address.upper(), connectable=True
        ) if client else None

        super().__init__(
            hass,
            _LOGGER,
            name=DOMAIN,
            update_interval=timedelta(seconds=update_interval),
        )
        _LOGGER.info("BluPow coordinator initialized for device: %s", self.client.address)

    async def _async_update_data(self) -> Dict[str, Any]:
        """Fetch data from the inverter."""
        _LOGGER.debug(f"Starting data update for {self.client.address}")
        
        try:
            if not self.client.is_connected:
                _LOGGER.info("Client not connected, attempting to connect...")
                await self.client.connect()

            if self.client.is_connected:
                # First, ensure we have the model number
                if not self.client.get_data().get('model_number'):
                    await self.client.read_device_info()
                
                # Then, fetch the main data block
                await self.client.read_realtime_data()

        except Exception as err:
            _LOGGER.error(f"Error communicating with device: {err}")
            # In case of any error, ensure we are disconnected to force a reconnect on next attempt
            await self.client.disconnect()
        
        data = self.client.get_data()
        _LOGGER.debug(f"Data received from client: {list(data.keys())}")
        _LOGGER.debug(f"Sample data values: {dict(list(data.items())[:5])}")
        return data

    @property
    def device_info(self) -> Dict[str, Any]:
        """Return basic device information."""
        model = "Unknown"
        if self.data and self.data.get('model_number'):
            model = self.data.get('model_number')

        name = "BluPow Device"
        if self.ble_device and self.ble_device.name:
            name = self.ble_device.name

        return {
            "identifiers": {(DOMAIN, self.client.address)},
            "name": name,
            "model": model,
            "manufacturer": "Renogy",
        }

    async def enable_test_mode(self) -> None:
        """Enable test mode with simulated data for debugging."""
        _LOGGER.info("Enabling test mode for BluPow coordinator")
        # Override get_data to return test data
        original_get_data = self.client.get_data
        self.client.get_data = self.client.get_test_data
        await self.async_refresh()

