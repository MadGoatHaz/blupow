# HANDOVER-V2-CHECKPOINT :: DO NOT EDIT THIS FILE WITHOUT REVIEWING HANDOVER.md
"""Data update coordinator for the BluPow integration."""
import logging
from typing import Any, Dict
from datetime import timedelta

from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator
from homeassistant.components import bluetooth

from .blupow_client import BluPowClient
from .const import DOMAIN

_LOGGER = logging.getLogger(__name__)


class BluPowDataUpdateCoordinator(DataUpdateCoordinator[Dict[str, Any]]):
    """Class to manage fetching BluPow data from the device."""

    def __init__(self, hass: HomeAssistant, client: BluPowClient, update_interval: int) -> None:
        """Initialize the data update coordinator."""
        self.client = client
        self.ble_device = bluetooth.async_ble_device_from_address(
            hass, client.address.upper(), connectable=True
        ) if client else None

        super().__init__(
            hass,
            _LOGGER,
            name=DOMAIN,
            update_interval=timedelta(seconds=update_interval),
        )
        _LOGGER.info("BluPow coordinator initialized for device: %s", self.client.address)

    async def _async_update_data(self) -> Dict[str, Any]:
        """
        Fetch data from the BluPow client.
        
        This method is called by the DataUpdateCoordinator to refresh the data.
        It calls the get_data() method of the client, which handles connection,
        data retrieval, and formatting.
        """
        _LOGGER.debug("Starting data update for %s", self.client.address)
        try:
            data = await self.client.get_data()
            _LOGGER.debug("Data received from client: %s", data.keys())
            return data
        except Exception as err:
            _LOGGER.error("Error fetching BluPow data: %s", err, exc_info=True)
            # In case of an unexpected error, return the offline structure
            # The client should handle most errors and return an offline dict,
            # but this is a fallback.
            return self.client._get_offline_data()

    @property
    def device_info(self) -> Dict[str, Any]:
        """Return basic device information."""
        model = "Unknown"
        if self.data and self.data.get('model_number'):
            model = self.data.get('model_number')

        name = "BluPow Device"
        if self.ble_device and self.ble_device.name:
            name = self.ble_device.name

        return {
            "identifiers": {(DOMAIN, self.client.address)},
            "name": name,
            "model": model,
            "manufacturer": "Renogy",
        }

