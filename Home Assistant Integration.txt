Home Assistant Integration Development Guide

1. Core Concepts & Terminology

Integration: A Python module package that allows Home Assistant to interact with a specific device, service, or protocol.

Platform: An older term, often referring to a specific component type within an integration (e.g., sensor.py, light.py, switch.py).

Device: A physical or logical piece of hardware (e.g., a smart bulb, a temperature sensor).

Entity: A representation of a device or service within Home Assistant (e.g., light.kitchen_lamp, sensor.living_room_temperature, switch.smart_plug). Entities are what the end-user interacts with in the UI and automation.

Configuration Flow: The process a user follows to configure an integration via the Home Assistant UI (e.g., entering IP addresses, API keys).

Discovery: The process where Home Assistant automatically finds devices on the network (e.g., via SSDP, mDNS, UPnP, MQTT) and suggests setting up the corresponding integration.

State: The current status of an entity (e.g., on, off, 25.5, playing).

Attributes: Additional information associated with an entity's state (e.g., brightness: 150, unit_of_measurement: '°C', friendly_name: 'Kitchen Lamp').

Service: Actions that can be performed on entities (e.g., light.turn_on, switch.turn_off, climate.set_temperature).

Domain: A category for entities and services (e.g., light, sensor, switch, climate).

Integration ID: A unique identifier for a specific instance of an integration, often generated by Home Assistant (e.g., my_device_123). Often used in config_id.

Entity ID: A unique identifier for an entity (e.g., light.kitchen_lamp). Formatted as domain.object_id.

2. Structure of an Integration

A typical integration directory structure looks like this:


custom_components/my_awesome_integration/

├── __init__.py             # Main entry point for the integration

├── manifest.json           # Integration metadata (dependencies, version, etc.)

├── config_flow.py          # (Optional) Handles configuration via the UI

├── options.py              # (Optional) Handles configuration options for the integration

├── helpers.py              # (Optional) Contains reusable helper functions

├── sensor/                 # (Optional) Directory for sensor platforms

│   ├── __init__.py

│   └── sensor.py           # Defines the logic for sensor entities

├── light/                  # (Optional) Directory for light platforms

│   ├── __init__.py

│   └── light.py            # Defines the logic for light entities

├── switch/                 # (Optional) Directory for switch platforms

│   ├── __init__.py

│   └── switch.py           # Defines the logic for switch entities

├── services/               # (Optional) Directory for custom services

│   ├── __init__.py

│   └── my_service.yaml     # Defines custom services

├── translations/           # (Optional) Directory for language translations

│   ├── en.json

│   └── fr.json

├── static/                 # (Optional) Directory for static assets (e.g., images)

│   └── logo.png

├── README.md               # (Optional) Integration documentation

└── tests/                  # (Optional) Unit tests

3. Key Files and Functions

__init__.py:

async_setup(hass, config): Required. Called when the integration is loaded. Used to perform initial setup based on configuration from configuration.yaml (e.g., setting up listeners, discovery). Returns True if successful, False otherwise.
async_setup_entry(hass, entry): Preferred. Called when the integration is set up via Configuration Flow or Discovery. Used to set up platforms (sensors, lights, etc.) associated with the ConfigEntry. Returns an awaitable.
async_unload_entry(hass, entry): Called to clean up resources when the integration is unloaded.
DOMAIN: Defined in __init__.py or manifest.json, representing the integration's domain (e.g., "my_awesome_integration").
PLATFORMS: A list of platforms supported by the integration (e.g., ["sensor", "light"]).
manifest.json:

domain: Required. The integration's domain.
name: Required. The human-readable name of the integration.
version: Required. The version of the integration.
codeowners: Recommended. List of GitHub usernames responsible for the integration.
dependencies: Optional. List of other integrations this one depends on (e.g., ["zeroconf"] for zeroconf discovery).
config_flow: Optional. True if the integration supports Configuration Flow.
discovery_able: Optional. True if the integration supports automatic discovery.
quality: Optional. "local", "cloud_push", "cloud". Indicates the nature of the integration.
issue_url: Optional. Link to the integration's issue tracker.
config_flow.py:

Inherits from homeassistant.config_entries.flow.ConfigFlow.

async_step_user(self, user_input): Handles the initial setup by the user via the UI.

async_step_discovery(self, discovery_info): Handles setup initiated by discovery.

async_show_form(self, step_id, data_schema=None, errors=None): Helper to display a configuration form to the user.

async_create_entry(self, title, data=None, options=None): Creates the ConfigEntry upon successful configuration.

options.py:

Inherits from homeassistant.config_entries.flow.OptionsFlow.

async_step_init(self, user_input): Handles configuring additional options for the integration after it's been set up.

Platform Files (e.g., sensor/sensor.py):

async_setup_platform(hass, config, async_add_entities, discovery_info=None): (Older method) Called to set up entities from configuration.yaml or discovery.
async_setup_entry(hass, entry, async_add_entities): (Preferred method) Called to set up entities based on a ConfigEntry.
async_add_entities(entities): A function provided by Home Assistant to add one or more entities.
Entity Classes: Define Python classes that inherit from the appropriate base class (e.g., homeassistant.components.sensor.SensorEntity, homeassistant.components.light.LightEntity). These classes implement properties like name, state, attributes, methods like async_update, async_turn_on, async_turn_off.
4. Key Home Assistant Base Classes

homeassistant.helpers.entity.Entity: Base class for all Home Assistant entities. Provides common properties like entity_id, name, state, attributes, available.

homeassistant.components.sensor.SensorEntity: Base class for sensor entities. Requires implementing state and optionally unit_of_measurement, icon, device_class.

homeassistant.components.light.LightEntity: Base class for light entities. Requires implementing async_turn_on, async_turn_off, is_on, and optionally brightness, rgb_color, etc.

homeassistant.components.switch.SwitchEntity: Base class for switch entities. Requires implementing async_turn_on, async_turn_off, is_on.

homeassistant.components.climate.ClimateEntity: Base class for climate entities. Requires implementing current_temperature, target_temperature, hvac_mode, async_set_temperature, async_set_hvac_mode.

5. Best Practices

Asyncio: Home Assistant is built on asyncio. Use async def and await extensively for I/O operations (network requests, file access, database calls). Avoid blocking the main event loop.

async_add_executor_job: Use hass.async_add_executor_job to run blocking synchronous code (e.g., complex calculations, legacy library calls) in a separate thread pool, preventing it from blocking the main event loop.

Error Handling: Use try...except blocks to handle potential errors during network communication, device interaction, or parsing. Log errors appropriately using _LOGGER.error(), _LOGGER.warning(), etc.

Logging: Use the standard Python logging module. Get a logger instance specific to your integration (e.g., _LOGGER = logging.getLogger(__name__)). Use _LOGGER.debug(), _LOGGER.info(), _LOGGER.warning(), _LOGGER.error(), _LOGGER.critical().

Configuration Flow: Prefer Configuration Flow (config_flow.py) over configuration.yaml setup for new integrations. It provides a better user experience.

Discovery: Implement discovery if possible (e.g., using Zeroconf, entry points) to make adding the integration easier for users.

Device Registry: Use the device_registry (introduced in HA 2021.6) to link entities to devices. This allows Home Assistant to group entities in the UI, show device information (manufacturer, model, firmware), and manage device lifecycle. Use hass.helpers.device_registry.async_get_or_create.

Entity Registry: Use the entity_registry to manage entity states, unique IDs, names, and icons. Use hass.helpers.entity_registry.async_get_or_create.

Constants: Use Home Assistant constants (e.g., CONF_HOST, STATE_ON, UNIT_CELSIUS) instead of hardcoding strings.

Device Classes: Use appropriate device_class attributes (e.g., SensorDeviceClass.TEMPERATURE, SensorDeviceClass.BATTERY, BinaryDeviceClass.MOTION) to provide better UI representation and automation capabilities.

Testing: Write unit tests using pytest for your integration. This helps ensure stability and makes maintenance easier.

Documentation: Write clear and concise documentation (README.md) for your integration, including installation instructions, configuration options, and examples.

6. Example: A Simple Sensor Integration

Let's create a basic integration called my_simple_sensor that reads a static value from a file.

custom_components/my_simple_sensor/manifest.json:

{

"domain": "my_simple_sensor",

"name": "My Simple Sensor",

"version": "0.1.0",

"codeowners": [

"@your_username"
],

"dependencies": [],

"config_flow": true,

"discovery_able": false

}

custom_components/my_simple_sensor/__init__.py:

python
Open
custom_components/my_simple_sensor/config_flow.py:

python
Open
custom_components/my_simple_sensor/sensor/sensor.py:

python
Open
How to Use the Example:

Create the directory structure custom_components/my_simple_sensor/.

Create the manifest.json, __init__.py, config_flow.py, and sensor/sensor.py files as shown above.

Create a file named my_simple_sensor_value.txt in your Home Assistant config directory and put a number in it (e.g., 12.34).

Restart Home Assistant.

Go to Configuration > Devices & Services > Add Integration.

Search for "My Simple Sensor" and select it.

Follow the configuration flow (it's simple in this case).

You should now see a sensor.my_simple_value entity in Home Assistant, displaying the value from the file.

7. Advanced Topics

Discovery: Implement discovery (using homeassistant.components.zeroconf, homeassistant.components.homebus, mDNS, etc.) to automatically find devices on the network.

Services: Define custom services in services/my_service.yaml and register them using hass.services.async_register.

Device & Entity Registry: Use hass.helpers.device_registry.async_get_or_create and hass.helpers.entity_registry.async_get_or_create to link entities to devices and manage their metadata. This is crucial for UI display and automation compatibility.

Translations: Provide translations for different languages in translations/en.json, translations/fr.json, etc.

Options Flow: Implement options.py to allow users to configure additional settings after the initial setup.

Unit Testing: Write tests using pytest and the homeassistant.testing.hass_component helper.

MQTT Integration: For devices that communicate via MQTT, use the homeassistant.components.mqtt helpers.

REST API: Create integrations for devices or services exposing REST APIs.

Webhooks: Implement integrations that allow external services to push data to Home Assistant.

Cloud Integrations: For integrations that interact with cloud services, you'll need to handle authentication (OAuth, API keys) and potentially use Home Assistant Cloud (Nabu Casa) for easier setup and development, or manage your own cloud infrastructure.

Breaking Changes: Be prepared for breaking changes in future Home Assistant versions.

8. Resources

Home Assistant Developer Documentation: https://developers.home-assistant.io/docs/ (This is your primary resource!)

Home Assistant Core Repository: https://github.com/home-assistant/core (Look at existing integrations for examples)

Home Assistant Community Forum: https://community.home-assistant.io/ (Ask questions, get help)

Home Assistant Discord: Join the Discord server for real-time support.

Developing Home Assistant integrations is a rewarding process that allows you to bring new devices and services into the smart home ecosystem. Start simple, follow the official documentation, and don't be afraid to ask for help from the community. Good luck!
