# HANDOVER-V2-CHECKPOINT :: DO NOT EDIT THIS FILE WITHOUT REVIEWING HANDOVER.md
"""Sensor platform for the BluPow integration."""
import logging
from typing import Any

from homeassistant.components.sensor import SensorEntity, SensorEntityDescription
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import CONF_ADDRESS
from homeassistant.core import HomeAssistant
from homeassistant.helpers.entity import DeviceInfo
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.update_coordinator import CoordinatorEntity

from .const import DEVICE_SENSORS, DOMAIN
from .coordinator import BluPowDataUpdateCoordinator

_LOGGER = logging.getLogger(__name__)


async def async_setup_entry(
    hass: HomeAssistant,
    entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up the BluPow sensor entities from a config entry."""
    coordinator: BluPowDataUpdateCoordinator = entry.runtime_data
    
    entities = [
        BluPowSensor(coordinator, description)
        for description in DEVICE_SENSORS
    ]
    async_add_entities(entities)
    _LOGGER.info("Added %d BluPow sensors", len(entities))


class BluPowSensor(CoordinatorEntity[BluPowDataUpdateCoordinator], SensorEntity):
    """A sensor entity for a BluPow device that uses the coordinator."""

    def __init__(
        self,
        coordinator: BluPowDataUpdateCoordinator,
        description: SensorEntityDescription,
    ) -> None:
        """Initialize the sensor."""
        super().__init__(coordinator)
        self.entity_description = description
        
        self._attr_unique_id = f"{coordinator.client.address}_{description.key}"
        # The device_info is provided by the coordinator
        self._attr_device_info = coordinator.device_info

    @property
    def native_value(self) -> Any:
        """Return the state of the sensor with proper null handling."""
        if not self.coordinator.data:
            return None
            
        value = self.coordinator.data.get(self.entity_description.key)
        
        # Handle various null/invalid value cases
        if value is None:
            return None
        
        # Handle string representations of null values
        if isinstance(value, str):
            if value.lower() in ['none', 'null', 'unknown', 'unavailable', '']:
                return None
            
            # Try to convert string numbers to appropriate type
            try:
                # For numeric sensors, try to convert to float first
                if self.entity_description.key in [
                    'input_voltage', 'output_voltage', 'battery_voltage', 'solar_voltage',
                    'input_current', 'output_current', 'charging_current', 'solar_current', 'load_current',
                    'load_active_power', 'charging_power', 'solar_power',
                    'battery_percentage', 'load_percentage',
                    'temperature', 'input_frequency', 'output_frequency'
                ]:
                    float_value = float(value)
                    # Return None for obviously invalid readings
                    if float_value < 0 and self.entity_description.key.endswith('_percentage'):
                        return None
                    if float_value > 1000 and self.entity_description.key.endswith('_voltage'):
                        return None  # Extremely high voltage, likely invalid
                    return float_value
            except (ValueError, TypeError):
                # If conversion fails, return the original string value
                pass
        
        # For numeric values, validate ranges
        if isinstance(value, (int, float)):
            # Validate percentage values
            if self.entity_description.key.endswith('_percentage'):
                if not (0 <= value <= 100):
                    return None
            
            # Validate voltage readings (reasonable ranges)
            if 'voltage' in self.entity_description.key:
                if value < 0 or value > 1000:  # 0-1000V seems reasonable
                    return None
            
            # Validate current readings
            if 'current' in self.entity_description.key:
                if value < 0 or value > 1000:  # 0-1000A seems reasonable
                    return None
        
        return value

    @property
    def available(self) -> bool:
        """Return if the entity is available."""
        if not self.coordinator.data:
            return False
        
        connection_status = self.coordinator.data.get('connection_status')
        
        # Available if:
        # 1. Connected and last update successful
        # 2. Using cached data (offline) but last update was successful
        # 3. In test mode
        is_available = (
            self.coordinator.last_update_success and 
            connection_status in ['connected', 'test_mode', 'offline']
        )
        
        # Only mark unavailable if explicitly disconnected AND no recent success
        if connection_status == 'disconnected':
            # Check if we have recent successful data (within last 10 minutes)
            last_update = self.coordinator.data.get('last_update')
            if last_update:
                try:
                    from datetime import datetime, timedelta
                    last_time = datetime.fromisoformat(last_update.replace('Z', '+00:00'))
                    if datetime.now() - last_time < timedelta(minutes=10):
                        is_available = True
                except:
                    pass  # If parsing fails, use default logic
        
        # Debug logging for sensor availability
        if not is_available:
            _LOGGER.debug(
                "Sensor %s unavailable: last_update_success=%s, connection_status=%s",
                self.entity_description.key,
                self.coordinator.last_update_success,
                connection_status
            )
        
        return is_available

    async def async_added_to_hass(self) -> None:
        """Handle entity added to hass with logging."""
        try:
            await super().async_added_to_hass()
            _LOGGER.info("BluPow sensor %s added to Home Assistant", self.entity_description.key)
        except Exception as err:
            _LOGGER.error("Error adding BluPow sensor %s to hass: %s", 
                         self.entity_description.key, err)

    async def async_will_remove_from_hass(self) -> None:
        """Handle entity removal with logging."""
        try:
            await super().async_will_remove_from_hass()
            _LOGGER.info("BluPow sensor %s removed from Home Assistant", self.entity_description.key)
        except Exception as err:
            _LOGGER.error("Error removing BluPow sensor %s from hass: %s", 
                         self.entity_description.key, err)

