# HANDOVER-V2-CHECKPOINT :: DO NOT EDIT THIS FILE WITHOUT REVIEWING HANDOVER.md
"""
BluPow Data Update Coordinator for Home Assistant

This coordinator manages data updates from Renogy inverters via Bluetooth LE.
It uses a subprocess-based approach with proper connect â†’ get data â†’ disconnect cycles
to ensure stable Bluetooth communication.
"""
import asyncio
import logging
import subprocess
import json
import time
from datetime import datetime, timedelta
from typing import Dict, Any, Optional

from homeassistant.core import HomeAssistant
from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed
from homeassistant.helpers.entity import DeviceInfo
from homeassistant.const import CONF_MAC

_LOGGER = logging.getLogger(__name__)

class CoordinatorHealthMonitor:
    """Monitor coordinator health and performance"""
    
    def __init__(self):
        self.update_attempts = 0
        self.successful_updates = 0
        self.consecutive_failures = 0
        self.last_success_time = None
        self.last_failure_time = None
        self.response_times = []
        self.error_history = []
        self.connection_cycles = 0
        self.successful_cycles = 0
        
    def record_update_attempt(self, success: bool, duration: float = 0.0, error: str = None):
        """Record an update attempt result"""
        self.update_attempts += 1
        
        if success:
            self.successful_updates += 1
            self.consecutive_failures = 0
            self.last_success_time = time.time()
            if duration > 0:
                self.response_times.append(duration)
                # Keep only last 50 response times
                if len(self.response_times) > 50:
                    self.response_times.pop(0)
        else:
            self.consecutive_failures += 1
            self.last_failure_time = time.time()
            if error:
                self.error_history.append({
                    'timestamp': time.time(),
                    'error': error,
                    'consecutive_failures': self.consecutive_failures
                })
                # Keep only last 20 errors
                if len(self.error_history) > 20:
                    self.error_history.pop(0)
    
    def record_connection_cycle(self, success: bool):
        """Record a connection cycle result"""
        self.connection_cycles += 1
        if success:
            self.successful_cycles += 1
    
    @property
    def success_rate(self) -> float:
        """Calculate overall success rate"""
        if self.update_attempts == 0:
            return 0.0
        return (self.successful_updates / self.update_attempts) * 100
    
    @property
    def connection_success_rate(self) -> float:
        """Calculate connection cycle success rate"""
        if self.connection_cycles == 0:
            return 0.0
        return (self.successful_cycles / self.connection_cycles) * 100
    
    @property
    def average_response_time(self) -> float:
        """Calculate average response time"""
        if not self.response_times:
            return 0.0
        return sum(self.response_times) / len(self.response_times)
    
    @property
    def is_healthy(self) -> bool:
        """Determine if coordinator is healthy"""
        if self.update_attempts < 3:
            return True  # Not enough data yet
        
        # Healthy if success rate > 70% and consecutive failures < 5
        return self.success_rate > 70.0 and self.consecutive_failures < 5
    
    def get_health_report(self) -> Dict[str, Any]:
        """Get comprehensive health report"""
        return {
            'update_attempts': self.update_attempts,
            'success_rate': round(self.success_rate, 1),
            'connection_success_rate': round(self.connection_success_rate, 1),
            'consecutive_failures': self.consecutive_failures,
            'average_response_time': round(self.average_response_time, 2),
            'is_healthy': self.is_healthy,
            'last_success_age': time.time() - self.last_success_time if self.last_success_time else None,
            'recent_errors': self.error_history[-3:] if self.error_history else []
        }

class BluPowDataUpdateCoordinator(DataUpdateCoordinator):
    """
    Coordinator for BluPow data updates using proper BLE connection cycles.
    
    Uses connect â†’ get data â†’ disconnect pattern for each update to ensure
    stable Bluetooth communication with Renogy devices.
    """

    def __init__(self, hass: HomeAssistant, mac_address: str, update_interval: int = 30):
        """Initialize the coordinator."""
        super().__init__(
            hass,
            _LOGGER,
            name="BluPow",
            update_interval=timedelta(seconds=update_interval),
        )
        
        self.mac_address = mac_address
        self._device_info = None
        self.health_monitor = CoordinatorHealthMonitor()
        self._last_health_log = 0
        self._health_log_interval = 300  # Log health every 5 minutes
        self._min_cycle_interval = 2.0  # Minimum 2 seconds between cycles
        self._last_cycle_time = 0
        
        _LOGGER.info(f"ðŸš€ BluPow coordinator initialized for device {mac_address}")
        _LOGGER.info(f"ðŸ“Š Update interval: {update_interval}s, Min cycle interval: {self._min_cycle_interval}s")

    async def _async_update_data(self) -> Dict[str, Any]:
        """
        Fetch data from the Renogy device using connect â†’ get data â†’ disconnect cycle.
        
        This method is called by Home Assistant at the configured update interval.
        It uses a subprocess to handle the Bluetooth communication to avoid
        blocking the main event loop and ensure proper connection management.
        """
        start_time = time.time()
        
        try:
            # Ensure minimum interval between connection cycles
            time_since_last_cycle = time.time() - self._last_cycle_time
            if time_since_last_cycle < self._min_cycle_interval:
                wait_time = self._min_cycle_interval - time_since_last_cycle
                _LOGGER.debug(f"â³ Waiting {wait_time:.1f}s before next connection cycle")
                await asyncio.sleep(wait_time)
            
            _LOGGER.debug(f"ðŸ”„ Starting data update cycle for {self.mac_address}")
            
            # Create the subprocess command to run our client
            cmd = [
                "python3", "-c", f"""
import sys
import asyncio
import json
import logging
import time
from pathlib import Path

# Add the integration directory to the path
sys.path.insert(0, '{Path(__file__).parent}')

from blupow_client import BluPowClient

async def get_data():
    client = BluPowClient('{self.mac_address}')
    start_time = time.time()
    
    try:
        # Connect
        connected = await client.connect()
        if not connected:
            return {{'error': 'Connection failed', 'timestamp': time.time()}}
        
        # Read device info first (this populates the internal cache)
        device_data = await client.read_device_info()
        
        # Get cached data (this is what the coordinator expects)
        data = client.get_data()
        
        # Disconnect
        await client.disconnect()
        
        # Add metadata
        if data and len(data) > 2:  # More than just connection_status and last_update
            data['_coordinator_meta'] = {{
                'cycle_time': time.time() - start_time,
                'timestamp': time.time(),
                'mac_address': '{self.mac_address}',
                'connection_method': 'cycle'
            }}
            print(f"SUCCESS: {{json.dumps(data)}}")
        else:
            print(f"ERROR: No data retrieved (got {{len(data)}} fields: {{list(data.keys()) if data else 'None'}})")
            
    except Exception as e:
        print(f"ERROR: {{str(e)}}")

asyncio.run(get_data())
"""
            ]
            
            # Run the subprocess with timeout
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(), 
                    timeout=30.0  # 30 second timeout for full cycle
                )
                
                self._last_cycle_time = time.time()
                
                # Parse the output
                stdout_text = stdout.decode().strip()
                stderr_text = stderr.decode().strip()
                
                if stderr_text:
                    _LOGGER.debug(f"ðŸ“‹ Subprocess stderr: {stderr_text}")
                
                # Look for SUCCESS line in output
                success_line = None
                for line in stdout_text.split('\n'):
                    if line.startswith('SUCCESS:'):
                        success_line = line[8:].strip()  # Remove "SUCCESS:" prefix
                        break
                
                if success_line:
                    try:
                        data = json.loads(success_line)
                        duration = time.time() - start_time
                        
                        # Record successful cycle
                        self.health_monitor.record_update_attempt(True, duration)
                        self.health_monitor.record_connection_cycle(True)
                        
                        _LOGGER.info(f"âœ… Data update successful in {duration:.2f}s - {len(data)} fields retrieved")
                        
                        # Log health periodically
                        self._log_health_if_needed()
                        
                        return data
                        
                    except json.JSONDecodeError as e:
                        error_msg = f"JSON decode error: {e}"
                        _LOGGER.error(f"âŒ {error_msg}")
                        self.health_monitor.record_update_attempt(False, time.time() - start_time, error_msg)
                        self.health_monitor.record_connection_cycle(False)
                        raise UpdateFailed(error_msg)
                else:
                    # Check for error in output
                    error_line = None
                    for line in stdout_text.split('\n'):
                        if line.startswith('ERROR:'):
                            error_line = line[6:].strip()  # Remove "ERROR:" prefix
                            break
                    
                    error_msg = error_line or f"No data received. Output: {stdout_text[:200]}"
                    _LOGGER.error(f"âŒ Data update failed: {error_msg}")
                    self.health_monitor.record_update_attempt(False, time.time() - start_time, error_msg)
                    self.health_monitor.record_connection_cycle(False)
                    raise UpdateFailed(error_msg)
                
            except asyncio.TimeoutError:
                # Ensure process is properly terminated
                try:
                    process.terminate()
                    await asyncio.wait_for(process.wait(), timeout=5.0)
                except asyncio.TimeoutError:
                    _LOGGER.warning("ðŸ”ª Force killing subprocess after timeout")
                    process.kill()
                    await process.wait()
                
                error_msg = "Subprocess timeout (30s)"
                _LOGGER.error(f"âŒ {error_msg}")
                self.health_monitor.record_update_attempt(False, time.time() - start_time, error_msg)
                self.health_monitor.record_connection_cycle(False)
                raise UpdateFailed(error_msg)
                
        except Exception as e:
            duration = time.time() - start_time
            error_msg = f"Coordinator error: {str(e)}"
            _LOGGER.error(f"âŒ {error_msg}")
            self.health_monitor.record_update_attempt(False, duration, error_msg)
            self.health_monitor.record_connection_cycle(False)
            raise UpdateFailed(error_msg)

    def _log_health_if_needed(self):
        """Log health status periodically"""
        current_time = time.time()
        if current_time - self._last_health_log >= self._health_log_interval:
            health_report = self.health_monitor.get_health_report()
            
            if self.health_monitor.update_attempts > 0:
                status = "ðŸŸ¢ HEALTHY" if self.health_monitor.is_healthy else "ðŸ”´ UNHEALTHY"
                _LOGGER.info(
                    f"ðŸ“Š BluPow Coordinator Health [{status}]: "
                    f"Success Rate: {health_report['success_rate']}%, "
                    f"Connection Success: {health_report['connection_success_rate']}%, "
                    f"Consecutive Failures: {health_report['consecutive_failures']}, "
                    f"Avg Response: {health_report['average_response_time']}s"
                )
            
            self._last_health_log = current_time

    @property
    def device_info(self) -> DeviceInfo:
        """Return device info for the Renogy inverter."""
        if self._device_info is None:
            # Extract device info from data if available
            device_name = "Renogy Inverter"
            model = "Unknown"
            
            if self.data:
                device_name = self.data.get('model', device_name)
                model = self.data.get('model', model)
            
            self._device_info = DeviceInfo(
                identifiers={("blupow", self.mac_address)},
                name=device_name,
                manufacturer="Renogy",
                model=model,
                sw_version=self.data.get('firmware_version') if self.data else None,
                configuration_url=None,
            )
        
        return self._device_info

    def get_health_status(self) -> Dict[str, Any]:
        """Get current health status for diagnostics"""
        return self.health_monitor.get_health_report()

    async def async_shutdown(self):
        """Shutdown the coordinator gracefully"""
        _LOGGER.info("ðŸ›‘ BluPow coordinator shutting down")
        
        # Log final health report
        if self.health_monitor.update_attempts > 0:
            health_report = self.health_monitor.get_health_report()
            _LOGGER.info(f"ðŸ“Š Final Health Report: {health_report}")

